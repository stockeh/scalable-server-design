package cs455.scaling.client;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Timer;
import cs455.scaling.util.Logger;
import cs455.scaling.util.TransmissionUtilities;

/**
 * There are multiple Clients in the system that send and receive data
 * to the server.
 * 
 * A client provides the following functionalities:
 * 
 * <ul>
 * <li>Connect and maintain an active connection to the server.</li>
 * <li>Regularly send data packets to the server. The pay loads for
 * these data packets are 8 KB of randomly generated bytes. The rate
 * at which each connection will generate packets is <i>R</i>
 * per-second.</li>
 * <li>The client will track hash codes of the data packets that it
 * has sent to the server. A server will acknowledge every packet that
 * it has received by sending the computed hash code back to the
 * respective client.</li>
 * </ul>
 * 
 * @author stock
 *
 */
public class Client {

  /**
   * Have the ability to log output INFO, DEBUG, ERROR configured by
   * Logger(INFO, DEBUG) and LOGGER#MASTER for ERROR settings.
   */
  private static final Logger LOG = new Logger( true, false );

  private List<String> hashes;

  private SocketChannel channel;

  private final ClientStatistics statistics;

  /**
   * Driver method to setup a new client.
   * 
   * A new Sender Thread is created to send messages from this client.
   * 
   * @param args command line arguments including; server-host,
   *        server-port, and messaging-rate.
   */
  public static void main(String[] args) {

    if ( args.length < 3 )
    {
      LOG.error( "USAGE: server-host server-port message-rate" );
      return;
    }
    LOG.info( "Client starting up at: " + new Date() + "\n" );

    int serverPort, messageRate;

    try
    {
      serverPort = Integer.parseInt( args[ 1 ] );
      messageRate = Integer.parseInt( args[ 2 ] );
    } catch ( NumberFormatException e )
    {
      LOG.error( "Unable to parse command line arguments. " + e.getMessage() );
      return;
    }
    Client client;

    try
    {
      client = new Client( args[ 0 ], serverPort );
    } catch ( IOException e )
    {
      LOG.error( "Unable to initialize. " + e.getMessage() );
      return;
    }
    ( new Thread( new SenderThread( client.statistics, client.channel,
        messageRate, client.hashes ) ) ).start();

    Timer timer = new Timer();
    final int interval = 20000; // 20 seconds in milliseconds
    timer.schedule( client.statistics, 0, interval );

    client.read( messageRate );
  }

  /**
   * Client constructor which establishes a new connection with the
   * server (as specified by the arguments). Allocates memory for the
   * receiving buffer, as well as a new <code>LinkedList</code> for the
   * computed hashes.
   * 
   * @param serverHost
   * @param serverPort
   * @throws IOException
   */
  private Client(String serverHost, int serverPort) throws IOException {
    channel =
        SocketChannel.open( new InetSocketAddress( serverHost, serverPort ) );

    hashes = new LinkedList<String>();

    statistics = new ClientStatistics();
  }

  /**
   * Continuously try to read from the socket channel into the received
   * buffer. New messages are acknowledged.
   * 
   * @param messageRate
   */
  private void read(int messageRate) {
    ByteBuffer receivingBuffer =
        ByteBuffer.allocate( TransmissionUtilities.FORTY_B );

    while ( true )
    {
      try
      {
        channel.read( receivingBuffer );

        acknowledgeResponse( receivingBuffer );

        receivingBuffer.clear();
      } catch ( IOException e )
      {
        LOG.error( "Unable to send / receive message. " + e.getMessage() );
      }
    }
  }

  /**
   * Acknowledge a response (containing a hash code), and remove it from
   * the transmitted hashes if found.
   * 
   * @param receivingBuffer contains the hash value
   */
  private void acknowledgeResponse(ByteBuffer receivingBuffer) {
    synchronized ( hashes )
    {
      String response = new String( receivingBuffer.array() ).trim();
      if ( hashes.remove( response ) )
      {
        statistics.received();
      } else
      {
        LOG.error( "Unable to remove the response: " + response
            + ", because it was not found." );
      }
    }
  }
}
